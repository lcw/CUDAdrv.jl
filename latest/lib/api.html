<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API wrappers · CUDAdrv.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CUDAdrv.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/usage.html">Usage</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href="api.html">API wrappers</a><ul class="internal"><li><a class="toctext" href="#Installation-properties-1">Installation properties</a></li><li><a class="toctext" href="#Initialization-1">Initialization</a></li><li><a class="toctext" href="#Error-Handling-1">Error Handling</a></li><li><a class="toctext" href="#Version-Management-1">Version Management</a></li><li><a class="toctext" href="#Device-Management-1">Device Management</a></li><li><a class="toctext" href="#Context-Management-1">Context Management</a></li><li><a class="toctext" href="#Module-Management-1">Module Management</a></li><li><a class="toctext" href="#Memory-Management-1">Memory Management</a></li><li><a class="toctext" href="#Stream-Management-1">Stream Management</a></li><li><a class="toctext" href="#Event-Management-1">Event Management</a></li><li><a class="toctext" href="#Execution-Control-1">Execution Control</a></li><li><a class="toctext" href="#Profiler-Control-1">Profiler Control</a></li></ul></li><li><a class="toctext" href="array.html">Arrays</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="api.html">API wrappers</a></li></ul><a class="edit-page" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/master/docs/src/lib/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API wrappers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-wrappers-1" href="#API-wrappers-1">API wrappers</a></h1><p>This section lists the package&#39;s public functionality that directly corresponds to functionality of the CUDA driver API. In general, the abstractions stay close to those of the CUDA driver API, so for more information on certain library calls you can consult the <a href="http://docs.nvidia.com/cuda/cuda-driver-api/">CUDA driver API reference</a>.</p><p>The documentation is grouped according to the modules of the driver API.</p><h2><a class="nav-anchor" id="Installation-properties-1" href="#Installation-properties-1">Installation properties</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.vendor" href="#CUDAdrv.vendor"><code>CUDAdrv.vendor</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Returns a string identifying the vendor of your CUDA driver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/base.jl#L158-L160">source</a></section><h2><a class="nav-anchor" id="Initialization-1" href="#Initialization-1">Initialization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.init" href="#CUDAdrv.init"><code>CUDAdrv.init</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Initialize the CUDA driver API.</p><p>This function is automatically called upon loading the package. You should not have to call this manually.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/init.jl#L3-L8">source</a></section><h2><a class="nav-anchor" id="Error-Handling-1" href="#Error-Handling-1">Error Handling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuError" href="#CUDAdrv.CuError"><code>CUDAdrv.CuError</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuError(code::Integer)
CuError(code::Integer, info::String)</code></pre><p>Create a CUDA error object with error code <code>code</code>. The optional <code>info</code> parameter indicates whether extra information, such as error logs, is known.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/base.jl#L107-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.name-Tuple{CUDAdrv.CuError}" href="#CUDAdrv.name-Tuple{CUDAdrv.CuError}"><code>CUDAdrv.name</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">name(err::CuError)</code></pre><p>Gets the string representation of an error code.</p><p>This name can often be used as a symbol in source code to get an instance of this error. For example:</p><pre><code class="language-julia-repl">julia&gt; using CUDAdrv

julia&gt; err = CuError(1)
CuError(1, ERROR_INVALID_VALUE)

julia&gt; name(err)
&quot;ERROR_INVALID_VALUE&quot;

julia&gt; CUDAdrv.ERROR_INVALID_VALUE
CuError(1, ERROR_INVALID_VALUE)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/errors.jl#L32-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.description-Tuple{CUDAdrv.CuError}" href="#CUDAdrv.description-Tuple{CUDAdrv.CuError}"><code>CUDAdrv.description</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">description(err::CuError)</code></pre><p>Gets the string description of an error code.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/errors.jl#L59-L63">source</a></section><h2><a class="nav-anchor" id="Version-Management-1" href="#Version-Management-1">Version Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.version-Tuple{}" href="#CUDAdrv.version-Tuple{}"><code>CUDAdrv.version</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">version()</code></pre><p>Returns the CUDA version as reported by the driver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/version.jl#L3-L7">source</a></section><h2><a class="nav-anchor" id="Device-Management-1" href="#Device-Management-1">Device Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuDevice" href="#CUDAdrv.CuDevice"><code>CUDAdrv.CuDevice</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuDevice(i::Integer)</code></pre><p>Get a handle to a compute device.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/devices.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.devices" href="#CUDAdrv.devices"><code>CUDAdrv.devices</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">devices()</code></pre><p>Get an iterator for the compute devices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/devices.jl#L166-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.name-Tuple{CUDAdrv.CuDevice}" href="#CUDAdrv.name-Tuple{CUDAdrv.CuDevice}"><code>CUDAdrv.name</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">name(dev::CuDevice)</code></pre><p>Returns an identifier string for the device.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/devices.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.totalmem-Tuple{CUDAdrv.CuDevice}" href="#CUDAdrv.totalmem-Tuple{CUDAdrv.CuDevice}"><code>CUDAdrv.totalmem</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">totalmem(dev::CuDevice)</code></pre><p>Returns the total amount of memory (in bytes) on the device.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/devices.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.attribute" href="#CUDAdrv.attribute"><code>CUDAdrv.attribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">attribute(dev::CuDevice, code)</code></pre><p>Returns information about the device.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/devices.jl#L147-L151">source</a></section><p>Certain common attributes are exposed by additional convenience functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.capability-Tuple{CUDAdrv.CuDevice}" href="#CUDAdrv.capability-Tuple{CUDAdrv.CuDevice}"><code>CUDAdrv.capability</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">capability(dev::CuDevice)</code></pre><p>Returns the compute capability of the device.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/devices.jl#L202-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.warpsize-Tuple{CUDAdrv.CuDevice}" href="#CUDAdrv.warpsize-Tuple{CUDAdrv.CuDevice}"><code>CUDAdrv.warpsize</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">warpsize(dev::CuDevice)</code></pre><p>Returns the warp size (in threads) of the device.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/devices.jl#L195-L199">source</a></section><h2><a class="nav-anchor" id="Context-Management-1" href="#Context-Management-1">Context Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuContext" href="#CUDAdrv.CuContext"><code>CUDAdrv.CuContext</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuContext(dev::CuDevice, flags::CUctx_flags=SCHED_AUTO)
CuContext(f::Function, ...)</code></pre><p>Create a CUDA context for device. A context on the GPU is analogous to a process on the CPU, with its own distinct address space and allocated resources. When a context is destroyed, the system cleans up the resources allocated to it.</p><p>Contexts are unique instances which need to be <code>destroy</code>ed after use. For automatic management, prefer the <code>do</code> block syntax, which implicitly calls <code>destroy</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context.jl#L20-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.destroy!-Tuple{CUDAdrv.CuContext}" href="#CUDAdrv.destroy!-Tuple{CUDAdrv.CuContext}"><code>CUDAdrv.destroy!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">destroy!(ctx::CuContext)</code></pre><p>Mark a context for destruction.</p><p>This does not immediately destroy the context, as there might still be dependent resources which have not been collected yet. The context will get freed as soon as all outstanding instances have been finalized.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context.jl#L99-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuCurrentContext" href="#CUDAdrv.CuCurrentContext"><code>CUDAdrv.CuCurrentContext</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">CuCurrentContext()</code></pre><p>Return the current context, or a NULL context if there is no active context (see <a href="api.html#Base.isnull-Tuple{CUDAdrv.CuContext}"><code>isnull</code></a>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context.jl#L123-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isnull-Tuple{CUDAdrv.CuContext}" href="#Base.isnull-Tuple{CUDAdrv.CuContext}"><code>Base.isnull</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isnull(ctx::CuContext)</code></pre><p>Indicates whether the current context is an invalid NULL context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context.jl#L135-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.activate-Tuple{CUDAdrv.CuContext}" href="#CUDAdrv.activate-Tuple{CUDAdrv.CuContext}"><code>CUDAdrv.activate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">activate(ctx::CuContext)</code></pre><p>Binds the specified CUDA context to the calling CPU thread.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context.jl#L142-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.synchronize-Tuple{CUDAdrv.CuContext}" href="#CUDAdrv.synchronize-Tuple{CUDAdrv.CuContext}"><code>CUDAdrv.synchronize</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">synchronize(ctx::CuContext=CuCurrentContext())</code></pre><p>Block for a context&#39;s tasks to complete.</p><p>The <code>ctx</code> parameter defaults to the current active context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context.jl#L184-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.device-Tuple{CUDAdrv.CuContext}" href="#CUDAdrv.device-Tuple{CUDAdrv.CuContext}"><code>CUDAdrv.device</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">device(ctx::Cucontext)</code></pre><p>Returns the device for the current context. The <code>ctx</code> parameter is to make sure that the current context is really active, and hence the returned device is valid.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context.jl#L165-L170">source</a></section><h3><a class="nav-anchor" id="Primary-Context-Management-1" href="#Primary-Context-Management-1">Primary Context Management</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuPrimaryContext" href="#CUDAdrv.CuPrimaryContext"><code>CUDAdrv.CuPrimaryContext</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuPrimaryContext(dev::CuDevice)</code></pre><p>Create a primary CUDA context for a given device.</p><p>Each primary context is unique per device and is shared with CUDA runtime API. It is meant for interoperability with (applications using) the runtime API.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context/primary.jl#L8-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuContext-Tuple{CUDAdrv.CuPrimaryContext}" href="#CUDAdrv.CuContext-Tuple{CUDAdrv.CuPrimaryContext}"><code>CUDAdrv.CuContext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">CuContext(pctx::CuPrimaryContext)
CuContext(f::Function, pctx::CuPrimaryContext)</code></pre><p>Retain the primary context on the GPU, returning a context compatible with the driver API. The primary context will be released when the returned driver context is finalized. For that reason, it is advised to use this function with <code>do</code> block syntax.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context/primary.jl#L31-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.isactive-Tuple{CUDAdrv.CuPrimaryContext}" href="#CUDAdrv.isactive-Tuple{CUDAdrv.CuPrimaryContext}"><code>CUDAdrv.isactive</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isactive(pctx::CuPrimaryContext)</code></pre><p>Query whether a primary context is active.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context/primary.jl#L110-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.flags-Tuple{CUDAdrv.CuPrimaryContext}" href="#CUDAdrv.flags-Tuple{CUDAdrv.CuPrimaryContext}"><code>CUDAdrv.flags</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">flags(pctx::CuPrimaryContext)</code></pre><p>Query the flags of a primary context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context/primary.jl#L117-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.setflags!-Tuple{CUDAdrv.CuPrimaryContext,CUDAdrv.CUctx_flags}" href="#CUDAdrv.setflags!-Tuple{CUDAdrv.CuPrimaryContext,CUDAdrv.CUctx_flags}"><code>CUDAdrv.setflags!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setflags!(pctx::CuPrimaryContext)</code></pre><p>Set the flags of a primary context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context/primary.jl#L124-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.unsafe_reset!-Tuple{CUDAdrv.CuPrimaryContext,Bool}" href="#CUDAdrv.unsafe_reset!-Tuple{CUDAdrv.CuPrimaryContext,Bool}"><code>CUDAdrv.unsafe_reset!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">unsafe_reset!(pctx::CuPrimaryContext, [checked::Bool=true])</code></pre><p>Explicitly destroys and cleans up all resources associated with a device&#39;s primary context in the current process. Note that this forcibly invalidates all contexts derived from this primary context, and as a result outstanding resources might become invalid.</p><p>It is normally unnecessary to call this function, as resource are automatically freed when contexts go out of scope. In the case of primary contexts, they are collected when all contexts derived from that primary context have gone out of scope.</p><p>The <code>checked</code> argument determines whether to verify that the primary context has become inactive after resetting the derived driver contexts. This may not be possible, eg. if the CUDA runtime API itself has retained an additional context instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/context/primary.jl#L62-L76">source</a></section><h2><a class="nav-anchor" id="Module-Management-1" href="#Module-Management-1">Module Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuModule" href="#CUDAdrv.CuModule"><code>CUDAdrv.CuModule</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuModule(data, options::Dict{CUjit_option,Any})
CuModuleFile(path, options::Dict{CUjit_option,Any})</code></pre><p>Create a CUDA module from a data, or a file containing data. The data may be PTX code, a CUBIN, or a FATBIN.</p><p>The <code>options</code> is an optional dictionary of JIT options and their respective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module.jl#L11-L19">source</a></section><h3><a class="nav-anchor" id="Function-Management-1" href="#Function-Management-1">Function Management</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuFunction" href="#CUDAdrv.CuFunction"><code>CUDAdrv.CuFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuFunction(mod::CuModule, name::String)</code></pre><p>Acquires a function handle from a named function in a module.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/function.jl#L9-L13">source</a></section><h3><a class="nav-anchor" id="Global-Variable-Management-1" href="#Global-Variable-Management-1">Global Variable Management</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuGlobal" href="#CUDAdrv.CuGlobal"><code>CUDAdrv.CuGlobal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuGlobal{T}(mod::CuModule, name::String)</code></pre><p>Acquires a typed global variable handle from a named global in a module.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/global.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eltype-Tuple{CUDAdrv.CuGlobal}" href="#Base.eltype-Tuple{CUDAdrv.CuGlobal}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eltype(var::CuGlobal)</code></pre><p>Return the element type of a global variable object.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/global.jl#L36-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get-Tuple{CUDAdrv.CuGlobal}" href="#Base.get-Tuple{CUDAdrv.CuGlobal}"><code>Base.get</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get(var::CuGlobal)</code></pre><p>Return the current value of a global variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/global.jl#L43-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.set-Union{Tuple{CUDAdrv.CuGlobal{T},T}, Tuple{T}} where T" href="#CUDAdrv.set-Union{Tuple{CUDAdrv.CuGlobal{T},T}, Tuple{T}} where T"><code>CUDAdrv.set</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">set(var::CuGlobal{T}, T)</code></pre><p>Set the value of a global variable to <code>val</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/global.jl#L55-L59">source</a></section><h3><a class="nav-anchor" id="Linker-1" href="#Linker-1">Linker</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuLink" href="#CUDAdrv.CuLink"><code>CUDAdrv.CuLink</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuLink()</code></pre><p>Creates a pending JIT linker invocation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/linker.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.addData" href="#CUDAdrv.addData"><code>CUDAdrv.addData</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addData(link::CuLink, name::String, data, type::CUjit_input)</code></pre><p>Add data to a link operation. The argument <code>typ</code> indicates the type of the data.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/linker.jl#L61-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.addFile" href="#CUDAdrv.addFile"><code>CUDAdrv.addFile</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addFile(link::CuLink, path::String, typ::CUjit_input)</code></pre><p>Add data from a file to a link operation. The argument <code>typ</code> indicates the type of the contained data.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/linker.jl#L84-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuLinkImage" href="#CUDAdrv.CuLinkImage"><code>CUDAdrv.CuLinkImage</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The result of a linking operation.</p><p>This object keeps its parent linker object alive, as destroying a linker destroys linked images too.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/linker.jl#L98-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.complete" href="#CUDAdrv.complete"><code>CUDAdrv.complete</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">complete(link::CuLink)</code></pre><p>Complete a pending linker invocation, returning an output image.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/linker.jl#L110-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuModule-Tuple{CUDAdrv.CuLinkImage,Vararg{Any,N} where N}" href="#CUDAdrv.CuModule-Tuple{CUDAdrv.CuLinkImage,Vararg{Any,N} where N}"><code>CUDAdrv.CuModule</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">CuModule(img::CuLinkImage, ...)
CuModule(f::Function, img::CuLinkImage, ...)</code></pre><p>Create a CUDA module from a completed linking operation. Options from <code>CuModule</code> apply.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/module/linker.jl#L141-L146">source</a></section><h2><a class="nav-anchor" id="Memory-Management-1" href="#Memory-Management-1">Memory Management</a></h2><h3><a class="nav-anchor" id="Pointer-based-(low-level)-1" href="#Pointer-based-(low-level)-1">Pointer-based (low-level)</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.alloc-Tuple{Integer}" href="#CUDAdrv.Mem.alloc-Tuple{Integer}"><code>CUDAdrv.Mem.alloc</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">alloc(bytes::Integer)</code></pre><p>Allocates <code>bytesize</code> bytes of linear memory on the device and returns a pointer to the allocated memory. The allocated memory is suitably aligned for any kind of variable. The memory is not cleared, use <a href="api.html#CUDAdrv.Mem.free-Tuple{CUDAdrv.OwnedPtr}"><code>free(::OwnedPtr)</code></a> for that.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L52-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.free-Tuple{CUDAdrv.OwnedPtr}" href="#CUDAdrv.Mem.free-Tuple{CUDAdrv.OwnedPtr}"><code>CUDAdrv.Mem.free</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">free(p::OwnedPtr)</code></pre><p>Frees device memory.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L67-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.info" href="#CUDAdrv.Mem.info"><code>CUDAdrv.Mem.info</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">info()</code></pre><p>Returns a tuple of two integers, indicating respectively the free and total amount of memory (in bytes) available for allocation by the CUDA context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L78-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.total" href="#CUDAdrv.Mem.total"><code>CUDAdrv.Mem.total</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">total()</code></pre><p>Returns the total amount of memory (in bytes), available for allocation by the CUDA context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L98-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.used" href="#CUDAdrv.Mem.used"><code>CUDAdrv.Mem.used</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">used()</code></pre><p>Returns the used amount of memory (in bytes), allocated by the CUDA context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L105-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.free-Tuple{}" href="#CUDAdrv.Mem.free-Tuple{}"><code>CUDAdrv.Mem.free</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">free()</code></pre><p>Returns the free amount of memory (in bytes), available for allocation by the CUDA context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L91-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.set" href="#CUDAdrv.Mem.set"><code>CUDAdrv.Mem.set</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">set(p::OwnedPtr, value::Cuint, len::Integer)</code></pre><p>Initializes device memory, copying the value <code>val</code> for <code>len</code> times.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L114-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.upload-Tuple{CUDAdrv.OwnedPtr,Ref,Integer}" href="#CUDAdrv.Mem.upload-Tuple{CUDAdrv.OwnedPtr,Ref,Integer}"><code>CUDAdrv.Mem.upload</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">upload(dst::OwnedPtr, src, nbytes::Integer)</code></pre><p>Upload <code>nbytes</code> memory from <code>src</code> at the host to <code>dst</code> on the device.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L125-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.download-Tuple{Ref,CUDAdrv.OwnedPtr,Integer}" href="#CUDAdrv.Mem.download-Tuple{Ref,CUDAdrv.OwnedPtr,Integer}"><code>CUDAdrv.Mem.download</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">download(dst::OwnedPtr, src, nbytes::Integer)</code></pre><p>Download <code>nbytes</code> memory from <code>src</code> on the device to <code>src</code> on the host.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L135-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.transfer" href="#CUDAdrv.Mem.transfer"><code>CUDAdrv.Mem.transfer</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">download(dst::OwnedPtr, src, nbytes::Integer)</code></pre><p>Transfer <code>nbytes</code> of device memory from <code>src</code> to <code>dst</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L145-L149">source</a></section><h3><a class="nav-anchor" id="Object-based-(high-level)-1" href="#Object-based-(high-level)-1">Object-based (high-level)</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.alloc-Tuple{Type,Integer}" href="#CUDAdrv.Mem.alloc-Tuple{Type,Integer}"><code>CUDAdrv.Mem.alloc</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">alloc{T}(len=1)</code></pre><p>Allocates space for <code>len</code> objects of type <code>T</code> on the device and returns a pointer to the allocated memory. The memory is not cleared, use <a href="api.html#CUDAdrv.Mem.free-Tuple{CUDAdrv.OwnedPtr}"><code>free(::OwnedPtr)</code></a> for that.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L159-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.upload-Union{Tuple{CUDAdrv.OwnedPtr{T},T}, Tuple{T}} where T" href="#CUDAdrv.Mem.upload-Union{Tuple{CUDAdrv.OwnedPtr{T},T}, Tuple{T}} where T"><code>CUDAdrv.Mem.upload</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">upload{T}(src::T)
upload{T}(dst::OwnedPtr{T}, src::T)</code></pre><p>Upload an object <code>src</code> from the host to the device. If a destination <code>dst</code> is not provided, new memory is allocated and uploaded to.</p><p>Note this does only upload the object itself, and does not peek through it in order to get to the underlying data (like <code>Ref</code> does). Consequently, this functionality should not be used to transfer eg. arrays, use <a href="array.html#CUDAdrv.CuArray"><code>CuArray</code></a>&#39;s <a href="array.html#Base.copy!-Union{Tuple{CUDAdrv.CuArray{T,N} where N,Array{T,N} where N}, Tuple{T}} where T"><code>copy!</code></a> functionality for that.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L174-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Mem.download-Tuple{CUDAdrv.OwnedPtr}" href="#CUDAdrv.Mem.download-Tuple{CUDAdrv.OwnedPtr}"><code>CUDAdrv.Mem.download</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">download{T}(src::OwnedPtr{T})</code></pre><p>Download an object <code>src</code> from the device and return it as a host object.</p><p>See <a href="api.html#CUDAdrv.Mem.upload-Tuple{CUDAdrv.OwnedPtr,Ref,Integer}"><code>upload</code></a> for notes on how arguments are processed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/memory.jl#L196-L202">source</a></section><h2><a class="nav-anchor" id="Stream-Management-1" href="#Stream-Management-1">Stream Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuStream" href="#CUDAdrv.CuStream"><code>CUDAdrv.CuStream</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuStream(flags=0)</code></pre><p>Create a CUDA stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/stream.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuDefaultStream" href="#CUDAdrv.CuDefaultStream"><code>CUDAdrv.CuDefaultStream</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">CuDefaultStream()</code></pre><p>Return the default stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/stream.jl#L44-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.synchronize-Tuple{CUDAdrv.CuStream}" href="#CUDAdrv.synchronize-Tuple{CUDAdrv.CuStream}"><code>CUDAdrv.synchronize</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">synchronize(s::CuStream)</code></pre><p>Wait until a stream&#39;s tasks are completed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/stream.jl#L51-L55">source</a></section><h2><a class="nav-anchor" id="Event-Management-1" href="#Event-Management-1">Event Management</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuEvent" href="#CUDAdrv.CuEvent"><code>CUDAdrv.CuEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuEvent()</code></pre><p>Create a new CUDA event.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/events.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.record" href="#CUDAdrv.record"><code>CUDAdrv.record</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">record(e::CuEvent, stream=CuDefaultStream())</code></pre><p>Record an event on a stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/events.jl#L42-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.synchronize-Tuple{CUDAdrv.CuEvent}" href="#CUDAdrv.synchronize-Tuple{CUDAdrv.CuEvent}"><code>CUDAdrv.synchronize</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">synchronize(e::CuEvent)</code></pre><p>Waits for an event to complete.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/events.jl#L50-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.elapsed" href="#CUDAdrv.elapsed"><code>CUDAdrv.elapsed</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">elapsed(start::CuEvent, stop::CuEvent)</code></pre><p>Computes the elapsed time between two events (in seconds).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/events.jl#L57-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.@elapsed" href="#CUDAdrv.@elapsed"><code>CUDAdrv.@elapsed</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@elapsed stream ex
@elapsed ex</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute on the GPU, as a floating-point number.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/events.jl#L69-L75">source</a></section><h2><a class="nav-anchor" id="Execution-Control-1" href="#Execution-Control-1">Execution Control</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.CuDim3" href="#CUDAdrv.CuDim3"><code>CUDAdrv.CuDim3</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CuDim3(x)

CuDim3((x,))
CuDim3((x, y))
CuDim3((x, y, x))</code></pre><p>A type used to specify dimensions, consisting of 3 integers for respectively the <code>x</code>, <code>y</code> and <code>z</code> dimension. Unspecified dimensions default to <code>1</code>.</p><p>Often accepted as argument through the <code>CuDim</code> type alias, eg. in the case of <a href="api.html#CUDAdrv.cudacall"><code>cudacall</code></a> or <a href="api.html#CUDAdrv.launch"><code>launch</code></a>, allowing to pass dimensions as a plain integer or a tuple without having to construct an explicit <code>CuDim3</code> object.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/execution.jl#L6-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.cudacall" href="#CUDAdrv.cudacall"><code>CUDAdrv.cudacall</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cudacall(f::CuFunction, griddim::CuDim, blockdim::CuDim, types, values;
         shmem=0, stream=CuDefaultStream())
cudacall(f::CuFunction, griddim::CuDim, blockdim::CuDim,
         shmem::Integer, stream::CuStream,
         types, values)</code></pre><p><code>ccall</code>-like interface for launching a CUDA function <code>f</code> on a GPU.</p><p>For example:</p><pre><code class="language-none">vadd = CuFunction(md, &quot;vadd&quot;)
a = rand(Float32, 10)
b = rand(Float32, 10)
ad = CuArray(a)
bd = CuArray(b)
c = zeros(Float32, 10)
cd = CuArray(c)

cudacall(vadd, 10, 1, (Ptr{Cfloat},Ptr{Cfloat},Ptr{Cfloat}), ad, bd, cd)
c = Array(cd)</code></pre><p>The <code>griddim</code> and <code>blockdim</code> arguments control the launch configuration, and should both consist of either an integer, or a tuple of 1 to 3 integers (omitted dimensions default to 1).</p><p>Both a version with and without keyword arguments is provided, the latter being slightly faster, but not providing default values for the <code>shmem</code> and <code>stream</code> arguments. In addition, the <code>types</code> argument can contain both a tuple of types, and a tuple type, again the former being slightly faster.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/execution.jl#L121-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.launch" href="#CUDAdrv.launch"><code>CUDAdrv.launch</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">launch(f::CuFunction, griddim::CuDim, blockdim::CuDim, args...;
       shmem=0, stream=CuDefaultStream())
launch(f::CuFunction, griddim::CuDim, blockdim::CuDim, shmem::Int, stream::CuStream, args...)</code></pre><p>Low-level call to launch a CUDA function <code>f</code> on the GPU, using <code>griddim</code> and <code>blockdim</code> as respectively the grid and block configuration. Dynamic shared memory is allocated according to <code>shmem</code>, and the kernel is launched on stream <code>stream</code>.</p><p>Arguments to a kernel should either be bitstype, in which case they will be copied to the internal kernel parameter buffer, or a pointer to device memory.</p><p>Both a version with and without keyword arguments is provided, the latter being slightly faster, but not providing default values for the <code>shmem</code> and <code>stream</code> arguments.</p><p>This is a low-level call, prefer to use <a href="api.html#CUDAdrv.cudacall"><code>cudacall</code></a> instead.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/execution.jl#L39-L55">source</a></section><h2><a class="nav-anchor" id="Profiler-Control-1" href="#Profiler-Control-1">Profiler Control</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.@profile" href="#CUDAdrv.@profile"><code>CUDAdrv.@profile</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@profile ex</code></pre><p>Run expressions while activating the CUDA profiler.</p><p>Note that this API is used to programmatically control the profiling granularity by allowing profiling to be done only on selective pieces of code. It does not perform any profiling on itself, you need external tools for that.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/profile.jl#L9-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Profile.start" href="#CUDAdrv.Profile.start"><code>CUDAdrv.Profile.start</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">start()</code></pre><p>Enables profile collection by the active profiling tool for the current context. If profiling is already enabled, then this call has no effect.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/profile.jl#L35-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CUDAdrv.Profile.stop" href="#CUDAdrv.Profile.stop"><code>CUDAdrv.Profile.stop</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stop()</code></pre><p>Disables profile collection by the active profiling tool for the current context. If profiling is already disabled, then this call has no effect.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGPU/CUDAdrv.jl/blob/4e5e35288e3cc2a919f0d59283f82ef1309cfef6/src/profile.jl#L43-L48">source</a></section><footer><hr/><a class="previous" href="../man/usage.html"><span class="direction">Previous</span><span class="title">Usage</span></a><a class="next" href="array.html"><span class="direction">Next</span><span class="title">Arrays</span></a></footer></article></body></html>
